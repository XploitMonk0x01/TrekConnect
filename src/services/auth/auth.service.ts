
// bcrypt and jsonwebtoken are for custom auth, so they remain.
// getDb is needed for custom auth to interact with the users collection.
// UserProfile type might need adjustment if firebaseUid was central.

// signIn and signUp call API routes that are intended for custom JWT-based auth.
// These are fine to keep, but their frontend callers (Firebase-based pages) are changing.

// googleSignIn was Firebase-specific, so it's removed.
// validateToken was for the JWTs generated by the custom API routes, so it's still relevant
// for validating sessions in a custom auth system.

import type { UserProfile } from '@/lib/types'; // UserProfile may need updates (e.g. remove firebaseUid)

export interface AuthUser { // This interface might represent the user object in your custom JWT payload
  id: string; // MongoDB _id
  email: string;
  name: string;
  photoUrl?: string | null; // Optional
}

export interface AuthResponse {
  user: AuthUser;
  token: string; // JWT
}

export class AuthError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'AuthError';
  }
}

// This function will now be called by your custom sign-up form.
export async function signUp(
  email: string,
  password: string,
  name: string
): Promise<AuthResponse> {
  const res = await fetch('/api/auth/signup', { // This API route handles custom registration
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ email, password, name }),
  });

  const data = await res.json();

  if (!res.ok) {
    throw new AuthError(data.error || 'Failed to sign up');
  }
  // The user object in 'data' should now come from MongoDB directly via the API route.
  // Ensure its structure matches AuthUser.
  return data;
}

// This function will now be called by your custom sign-in form.
export async function signIn(
  email: string,
  password: string
): Promise<AuthResponse> {
  const res = await fetch('/api/auth/signin', { // This API route handles custom login
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ email, password }),
  });

  const data = await res.json();

  if (!res.ok) {
    throw new AuthError(data.error || 'Failed to sign in');
  }
  // The user object in 'data' comes from MongoDB via the API route.
  // Ensure its structure matches AuthUser.
  return data;
}

// This function validates the custom JWT.
export async function validateToken(token: string): Promise<AuthUser> {
  const res = await fetch('/api/auth/validate', { // This API route validates the custom JWT
    headers: {
      Authorization: `Bearer ${token}`,
    },
  });

  const data = await res.json();

  if (!res.ok) {
    throw new AuthError(data.error || 'Invalid token');
  }
  // Data should be the user object (payload of the JWT).
  return data;
}

// This function can fetch a user profile from MongoDB using the user's MongoDB ID.
// It's similar to what was in src/services/auth.ts but specifically for MongoDB _id.
export async function getUserById(userId: string): Promise<UserProfile | null> {
  try {
    // This API route should fetch user by MongoDB _id.
    // Ensure /api/users/[userId]/route.ts is adapted to use MongoDB _id
    // if it was previously relying on Firebase UID.
    const res = await fetch(`/api/users/${userId}`);

    if (!res.ok) {
      if (res.status === 404) {
        return null;
      }
      throw new Error('Failed to fetch user by ID');
    }
    const userProfileData = await res.json();
    // Ensure this data is correctly mapped to UserProfile type.
    // The UserProfile type should no longer contain firebaseUid.
    return userProfileData as UserProfile; // Adjust mapping if necessary
  } catch (error) {
    console.error('Error fetching user by ID:', error);
    return null;
  }
}

// googleSignIn function removed as it was Firebase-specific.
// A custom Google OAuth flow would require a new service function.
